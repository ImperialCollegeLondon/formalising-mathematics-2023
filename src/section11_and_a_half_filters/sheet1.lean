/-
Copyright (c) 2023 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author : Kevin Buzzard
-/

import tactic -- imports all the Lean tactics
import order.filter.basic

/-!

# Filters

## What is a filter?

Morally, a filter on a type `α` is a "generalised subset of `α`". By this I mean that each subset 
of `α` gives rise to a filter, but there are other "ideas", such as "an infinitesimal neighbourhood of
a point in a topological space" or "a neighbourhood of infinity in a totally ordered set", which can be 
expressed as filters but not as sets (Isaac Newton might have wanted to have `dx` as "a real number
infinitesimally close to 0", but the modern treatments of real numbers don't allow `dx` as elements;
filters enable you to recover these thoughts)

The property which we want a "generalised subset" to have, is that it is uniquely determined
by the *actual* subsets which it's containined in. Let's use this point of view to figure
out the definition of a filter.

If `F` is a "generalised subset" of a type `α`, then then what properties should
the collection of *actual* subsets of `α` which contain `F` have?

1) If `S` contains `F` and `S ⊆ T` then `T` contains `F`.
2) If `S` and `T` contain `F`, then so does `S ∩ T`
3) The set `α` itself (or, in Lean speak, `set.univ : set α`) contains `F`.

The way that these "generalised subsets" of `α` are modelled is precisely as collections
of subsets of `α` satisfying these three axioms.

## The formal definition

structure filter (α : Type*) :=
(sets                   : set (set α))
(univ_sets              : set.univ ∈ sets)
(sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets)
(inter_sets {x y}       : x ∈ sets → y ∈ sets → x ∩ y ∈ sets)

In other words, to give a filter on a type `α` is to give a set of subsets of `α` satisfying
the three axioms above.

Some people add in an extra fourth axiom, saying that the empty set is not allowed to
be in `sets`. This is a way of saying that the empty set is not allowed to be a
generalised subset of `α`. But it's certainly a subset of `α`, so in mathlib we do not
include this fourth axiom. To me this missing axiom feels analogous to an axiom saying
that e.g. a ring is not allowed to be an ideal of itself; it might seem initially like
a good idea (because then "maximal ideals" really are maximal elements in the set of
ideals) but it causes a lot of confusion later on because you have to constantly deal
with the special case which you've disallowed.

## Notation, helpful tactics and helpful theorems

We are not going to build filters from first principles, we will be
using Lean's API for filters. 

Say `α : Type` and `F : filter α` and `S : set α`. The notation `S ∈ F` is
defined to mean `S ∈ F.sets`. You should think of it as morally meaning `F ⊆ S`,
but this doesn't make sense because `F` is a filter, not a subset.

The `ext` tactic can be used to reduce a goal `F = G` to a goal of
the form `∀ S, S ∈ F ↔ S ∈ G`.

The fields of the structure mention things like `S ∈ F.sets`, so the
axioms are restated with different names, but using the `S ∈ F` notation.
The lemmas corresponding to the definitions are:

`univ_mem : univ ∈ F`
`mem_of_superset : S ∈ F → S ⊆ T → T ∈ F`
`inter_mem : S ∈ F → T ∈ F → S ∩ T ∈ F`

These lemmas in the `filter` namespace, i.e. their full names are
`filter.univ_mem_sets` etc. But we are about to say `open filter`
which means that you don't have to type this `filter.` thing in front of every
lemma you need about filters. In fact we'll also be using a bunch of
stuff about sets, like `set.inter_subset_left`, so why don't we `open set`
as well.
-/

open filter set

-- Variables!
-- let `α` be a type, let `F` be a filter on `α`, and let `S` and `T`
-- denote subsets of `α`.

variables (α : Type) (F : filter α) (S T : set α)

/-
Here's a lemma about filters: Two sets `S` and `T` are both in
a filter `F` if and only if their intersection is. See if you can deduce
it from the axioms of a filter.

For this one it's useful to know the following results (from the set namespace)
`inter_subset_left S T : S ∩ T ⊆ S`
and
`inter_subset_right S T : S ∩ T ⊆ S`
-/
example : S ∩ T ∈ F ↔ S ∈ F ∧ T ∈ F :=
begin
  sorry,
end

/-

## Principal filters

Surely a subset of `α` should be a generalised subset of `α`! So there
should be a map `set α → filter α`. It's called `principal` and it
has notation `𝓟`. The principal filter `𝓟 X` generated by `X : set α` is the 
subsets of `α` which contain `X`. Prove that it's a filter.

Helpful for this exercise:
`mem_univ s : s ∈ univ`
`subset.trans : A ⊆ B → B ⊆ C → A ⊆ C`
`subset_inter : X ⊆ S → X ⊆ T → X ⊆ S ∩ T`
(note that you could probably prove those last two things directly yourself,
but we may as well use the interface for sets given that it's there)
`mem_set_of_eq : x ∈ {a : α | p a} = p x`
(this one is definitional, so you could use `change` instead, or just
not rewrite it at all)

-/

-- this is called `𝓟 X` in mathlib but let's just make it ourselves.
example (X : set α) : filter α :=
{ sets := {S : set α | X ⊆ S},
  univ_sets := begin
    sorry,
  end,
  sets_of_superset := begin
    sorry,
  end,
  inter_sets := begin
    sorry,
  end }

-- The notation for the principal filter generated by `X : set α` is `𝓟 X`.
-- This notation is in the "filter locale", which is just a posh way
-- of saying that you have to type

open_locale filter

-- in order to get the notation.
