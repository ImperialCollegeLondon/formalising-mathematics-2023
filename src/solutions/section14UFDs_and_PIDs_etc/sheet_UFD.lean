/-
Copyright (c) 2023 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author : Kevin Buzzard
-/

import tactic
import ring_theory.unique_factorization_domain -- UFDs
import data.polynomial.field_division -- polynomial rings over a field and stuff
/-

# Unique Factorization Domains

Again this is mostly a showcase

Internally the definition of UFD is a bit weird. 

A binary relation ★ is *well-founded* if you can't have an infinite decreasing
sequence a₂ ★ a₁, a₃ ★ a₂, a₄ ★ a₃, ... . For example `<` is well-founded
on the naturals, but `≤` is not, and `<` is not well-founded on the integers.

If `R` is a commutative ring, let's define `a ★ b` to mean "a strictly divides b",
i.e. that there exists a non-unit `c` such that `b = a * c`. The mathlib folks
in their wisdom decided to call `R` a `wf_dvd_monoid` ("well-founded under division")
if this relation is well-founded. For example the integers are a `wf_dvd_monoid`,
because (for example) 24 ★ 0, 12 ★ 24, 3 ★ 12, 1 ★ 3, but there's no solution to `x ★ 1`. 

-/

example : wf_dvd_monoid ℤ := by apply_instance

-- In fact (if you know what this means): any Noetherian integral domain is a `wf_dvd_monoid`:

example (R : Type) [comm_ring R] [is_domain R] [is_noetherian_ring R] : wf_dvd_monoid R := 
by apply_instance 

/-

...and in particular any PID is a `wf_dvd_monoid`.

In a `wf_dvd_monoid` everything factors into irreducibles, but the factorization might
not be unique (take for example `ℤ[√-5]` or your favourite non-UFD domain which is Noetherian.
The problem is that the concept of prime and irreducible don't coincide in rings such as this.
In Lean it turns out that the definition of UFD is "`wf_dvd_monoid`, and irreducible ↔ prime",
and it's a theorem that this is mathematically equivalent to the usual definition. Here's
how to say "let `R` be a UFD":

-/

variables (R : Type) [comm_ring R] [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R]
-- We say `R` is a *principal ideal ring* if all ideals are principal.
-- We say `R` is a *domain* if it's an integral domain. 
-- We say `R` is a *principal ideal domain* if it's both.

-- So here's how to say "Assume `R` is a PID":

variables [is_principal_ideal_ring R] [is_domain R]

-- Note that both of these are typeclasses, so various things should
-- be automatic.

example : ∀ a b : R, a * b = 0 → a = 0 ∨ b = 0 :=
begin
  intros a b,
  apply eq_zero_or_eq_zero_of_mul_eq_zero, -- typeclass inference 
  -- magically extracts the assumption from `is_domain`
end

example : (0 : R) ≠ 1 :=
begin
  -- this is another consequence of being an integral domain
  apply zero_ne_one,
end

example (I : ideal R) : I.is_principal :=
begin
  -- typeclass inference system finds `is_principal_ideal_ring` and
  -- uses it automatically
  exact is_principal_ideal_ring.principal I,
end

example (I : ideal R) : ∃ j, I = ideal.span {j} :=
begin
  -- to make a term of type `is_principal I` you need to give one proof,
  -- but we still need to do `cases` or equivalent (I used `obtain` below)
  -- to get this proof out.
  obtain ⟨h⟩ := is_principal_ideal_ring.principal I,
  exact h,
end

-- Typeclass inference knows a bunch of theorems about PIDs and which things are PIDs.
-- Examples:

-- integers are a PID
example : is_principal_ideal_ring ℤ := begin
  apply_instance
end

-- just check the domain bit:
example : is_domain ℤ := begin
  apply_instance
end

-- a field is a PID
example (k : Type) [field k] : is_principal_ideal_ring k :=
begin
  apply_instance
end

example (k : Type) [field k] : is_domain k :=
begin
  apply_instance
end

open_locale polynomial -- to get `k[X]` notation instead of `polynomial k`

-- polys over a field are a PID
example (k : Type) [field k] : is_principal_ideal_ring k[X] :=
begin
  apply_instance
end

example (k : Type) [field k] : is_domain k[X] :=
begin
  apply_instance
end

-- if all ideals of a ring are principal then the ring is a principal ideal ring
example (A : Type) [comm_ring A] (h : ∀ I : ideal A, I.is_principal) : is_principal_ideal_ring A :=
{ principal := h } -- it's a structure, with one field called `principal`.

-- see if you can prove that the ideal generated by 4 and 6 in any commutative ring is principal.
example (A : Type) [comm_ring A] : (ideal.span ({4, 6} : set A)).is_principal :=
begin
  use 2,
  simp only [ideal.submodule_span_eq], -- I squeezed all simps in this proof
  apply submodule.span_eq_span, -- ideals are submodules
  { intros x hx,
    simp only [set.mem_insert_iff, set.mem_singleton_iff] at hx,
    rcases hx with (rfl | rfl),
    { simp only [ideal.submodule_span_eq, set_like.mem_coe],
      rw ideal.mem_span_singleton,
      use 2,
      norm_num, },
    { simp only [ideal.submodule_span_eq, set_like.mem_coe],
      rw ideal.mem_span_singleton,
      use 3,
      norm_num, },    
  },
  { rw set.singleton_subset_iff,
    simp only [ideal.submodule_span_eq, set_like.mem_coe],
    rw ideal.mem_span_pair, -- found whilst looking for `ideal.mem_span` stuff
    use [-1,1],
    norm_num, },
end

