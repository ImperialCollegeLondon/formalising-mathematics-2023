/-
Copyright (c) 2023 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author : Kevin Buzzard
-/

import tactic -- imports all the Lean tactics
import order.filter.basic

/-!

# The order (≤) on filters

We think of filters as generalised subsets, and just as subsets are partially ordered
by `⊆`, filters are partially ordered too, by `≤`. Recall that a subset `X : set α`
of `α` gives rise to a principal filter `𝓟 X : filter α`, and we definitely
want `X ⊆ Y ↔ 𝓟 X ≤ 𝓟 Y` so let's think about how this should work. If `F` and `G`
are filters, then `F ≤ G` should mean "the generalised subset `F` is contained
in the generalised subset `G`", so it should mean "if a normal subset of α contains
`G` then it contains `F`", so it should mean `G.sets ⊆ F.sets`, which is in fact
the definition. Note that the smaller the filter `F`, the bigger the collection
`F.sets`, because `F` is contained in more sets!

In the `filter` namespace there's a lemma


Let's formalise this. Show that 𝓟 S ≤ 𝓟 T ↔ S ⊆ T.
Note that this is called `principal_mono` in mathlib but 
there's no harm in proving it yourself.

Some helpful lemmas (all in the `filter` namespace):

`mem_principal : T ∈ 𝓟 S ↔ S ⊆ T`
`mem_principal_self S : S ∈ 𝓟 S`
`le_def : F ≤ G ↔ ∀ (S : set α), S ∈ G → S ∈ F`

-/

variable {α : Type}

open filter set -- so we don't keep having to type `filter.le_def` and `set.subset.trans` etc

open_locale filter -- for 𝓟 notation

example (S T : set α) : 𝓟 S ≤ 𝓟 T ↔ S ⊆ T :=
begin
  split,
  { intro h,
    rw le_def at h,
    have hT : T ∈ 𝓟 T := mem_principal_self T,
    specialize h T hT,
    rwa mem_principal at h },
  { intro hST,
    rw le_def,
    intros X hX,
    rw mem_principal at hX ⊢,
    exact subset.trans hST hX }
end

-- Here's another useful lemma about principal filters.
-- It's called `le_principal_iff` in mathlib but why
-- not try proving it yourself?

example (F : filter α) (S : set α) : F ≤ 𝓟 S ↔ S ∈ F :=
begin
  rw le_def,
  split,
  { intro h,
    apply h,
    exact mem_principal_self S },
  { intros hSF X hX,
    rw mem_principal at hX,
    exact mem_of_superset hSF hX },
end



/-

## Filters are a complete lattice

First I claim that if Fᵢ are a bunch of filters, indexed by `i : I`, then
the intersection of `Fᵢ.sets` is also a filter. Let's check this.

-/

def LUB {I : Type} (F : I → filter α) : filter α :=
{ sets := {X | ∀ i, X ∈ F i},
  univ_sets := begin
    intro i,
    apply univ_mem,
  end,
  sets_of_superset := begin
    intros S T hS hST i,
    apply mem_of_superset _ hST,
    apply hS,
  end,
  inter_sets := begin
    intros S T hS hT i,
    exact inter_mem (hS i) (hT i),
  end }

/-

Now let's check that this is a least upper bound for the Fᵢ! We check the
two axioms.

-/

-- it's an upper bound
example (I : Type) (F : I → filter α) (i : I) : F i ≤ LUB F :=
begin
  intros S hS,
  apply hS,
end

-- it's ≤ all other upper bounds
example (I : Type) (F : I → filter α) (G : filter α) (hG : ∀ i, F i ≤ G) : LUB F ≤ G :=
begin
  intros S hS i,
  apply hG,
  exact hS,
end


/-

Just like it's possible to talk about the topological space generated
by a collection of subsets of `α` -- this is the smallest topology
for which the given subsets are all open -- it's also possible to talk
about the filter generated by a collection of subsets of `α`. One
can define it as the intersection of all the filters that contain your
given collection of subsets (we just proved above that this is a filter).
This gives us a definition of greatest lower bound for filters too.

-/

-- greatest lower bound of filters Fᵢ is the least upper bound of the filters G whose `sets`
-- contain all of the `Fᵢ.sets`
def GLB {I : Type} (F : I → filter α) : filter α := LUB (λ (G : {G : filter α | ∀ i, (F i).sets ⊆ G.sets}), G.1)

-- it's a lower bound
example (I : Type) (F : I → filter α) (i : I) : GLB F ≤ F i :=
begin
  rintros S hS ⟨G, hG⟩,
  dsimp,
  apply hG _ hS,
end

-- it's ≥ all other lower bounds
example (I : Type) (F : I → filter α) (G : filter α) (hG : ∀ i, G ≤ F i) : G ≤ GLB F :=
begin
  intros S hS,
  unfold GLB at hS,
  dsimp at hS,
  unfold LUB at hS,
  dsimp at hS,
  specialize hS ⟨G, _⟩,
  { exact hG },
  { exact hS },
end